@page "/backlog"
@using Tasky.Shared.DTOs;
@inject IJSRuntime JS
@inject ITaskService taskService
@inject IMemberService memberService
@inject IStatusService statusService
@inject ISprintService sprintService
@attribute [Authorize]

@if (message != string.Empty)
{
    <div style="position: sticky; top: 0; z-index: 1; background: pink;">@message <span @onclick="ResetMessage">Close</span></div>
}

@if (!isLoading)
{
    <div class="d-flex gap-5 flex-wrap ">
        <MudButton @onclick="AutoOrder">Auto Order Backlog</MudButton>
        @if (ShowOrHideAcceptanceCriteria == false)
        {
            <MudButton @onclick="ToggleAcceptanceCriteriaVisibility">
                Show Acceptance Criteria
            </MudButton>
        }
        else
        {
            <MudButton @onclick="ToggleAcceptanceCriteriaVisibility">
                Hide Acceptance Criteria
            </MudButton>
        }
        @if(ShowUserStoriesOrTaskName == false)
        {
            <MudButton @onclick="ToggleShowStoriesOrTaskName">Show User Stories</MudButton>
        }
        else
        {
            <MudButton @onclick="ToggleShowStoriesOrTaskName">Show Task Names</MudButton>
        }
        <CompletedTasksComponent @ref="CompletedTasksComponent" Tasks="tasks" Subtasks="subtasks" LastStatus="lastStatus" ListUpdated="RefreshList" />
        <ProductGoalComponent />
    </div>
    <EpicComponent Tasks="tasks" RefreshList="HandleEpicChange" EpicDeleted="HandleRefresh"></EpicComponent>
}




@if (isLoading)
{
    <LoadingIndicatorComponent />
}

@if (isLoading == false && tasks.Count == 0)
{
    <div style="font-size: 1rem; font-weight: bold;">Click the button to add your first task!</div>
}


<div class="backlog-page-container" style="margin-top: 2rem;">
    <DropContainer IdNumber="HandleSprintChange" Payload="Payload" RemoveFromSprint="HandleRefresh" OnDrop="HandleRefresh"></DropContainer>

    <div class="d-flex flex-column">

        @foreach (var task in tasks)
        {
            @if (task.isSubTask == false)
            {
                if (task.Status != lastStatus)
                {
                    <TaskComponent @key="task.TaskId"
                       ShowOrHideCriteria="@ShowOrHideAcceptanceCriteria"
                       ShowUserStoriesOrTaskName="@ShowUserStoriesOrTaskName"
                       Task="task"
                       CurrentSprintId="CurrentSprint.SprintId"
                       RefreshList="RefreshList"
                       CallSubTask="() => AddNewSubTask(task.TaskId)"
                       SimpleStateChange="RemoveTaskWithoutCallingDB"
                       OnTaskDragged="HandleTaskDragged"
                       OnOrderUpdated="UpdateTaskAsync"
                     />
                }
            }
        }


    </div>
</div>


<div class="centerTask">
    <MudFab Color="Color.Info" Style="margin-top: 2rem; margin-left: 10rem;" StartIcon="@Icons.Material.Filled.Add" Size="Size.Medium" @onclick="AddNewTask" />
</div>



@code {
    private bool isLoading = true;
    public bool ShowOrHideAcceptanceCriteria = false;
    public bool ShowUserStoriesOrTaskName = false;
    private string message = string.Empty;

    void ToggleShowStoriesOrTaskName()
    {
        ShowUserStoriesOrTaskName = !ShowUserStoriesOrTaskName;
        StateHasChanged();
    }

    public TaskComponent? taskComponent;
    public NoteModel? Payload;



    void HandleTaskDragged(NoteModel payload)
    {
        //When the drag starts, pass the payload to the index page
        Payload = payload;
    }

    async void HandleSprintChange(int sprintId)
    {
        await sprintService.GetSprintById(sprintId);
        CurrentSprint = sprintService.Sprint;
        StateHasChanged();
    }

    async void HandleEpicChange(int taskId)
    {
        var updatedTask = await taskService.GetTaskById(taskId);
        var taskToUpdate = tasks.Find(x => x.TaskId == taskId);

        taskToUpdate.EpicId = updatedTask.EpicId;
        StateHasChanged();
    }

    async void HandleRefresh()
    {
        tasks = await taskService.GetTasksInOrder();
        StateHasChanged();
    }

    public async Task UpdateTaskAsync(NoteModel targetTask)
    {
        if (Payload.isSubTask == true)
        {
            if (targetTask != null && Payload != null && Payload != targetTask)
            {
                var currentIndex = subtasks.IndexOf(Payload);
                int targetIndex;
                subtasks.RemoveAt(currentIndex);

                if (targetTask.isSubTask == false)
                {
                    //if target index is a task
                    //reassign the subtask to that task, regardless of order
                    Payload.LinkTo = targetTask.TaskId;
                    await taskService.UpdateTask(Payload);
                    RefreshList();
                }
                else if (targetTask.isSubTask == true)
                {
                    //check if the target is a subtask
                    if (targetTask.LinkTo == Payload.LinkTo)
                    {
                        //if the target it a subtask and the task they're linked to is the same then reorder
                        targetIndex = subtasks.IndexOf(targetTask);

                        if (currentIndex < targetIndex)
                        {
                            subtasks.Insert(targetIndex - 1, Payload);
                            AutoOrderSubtaskSet((int)targetTask.LinkTo);
                        }
                        else
                        {
                            subtasks.Insert(targetIndex, Payload);
                            AutoOrderSubtaskSet((int)targetTask.LinkTo);
                        }
                    }
                    else
                    {
                        //if the linkto is different then change payload link to to the new id.
                        Payload.LinkTo = targetTask.LinkTo;
                        await taskService.UpdateTask(Payload);
                        RefreshList();
                    }
                }
            }
        }
        else
        {
            if (targetTask != null)
            {
                if (targetTask != null && Payload != null && Payload != targetTask)
                {
                    var currentIndex = tasks.IndexOf(Payload);
                    var targetIndex = tasks.IndexOf(targetTask);
                    tasks.RemoveAt(currentIndex);

                    if (currentIndex < targetIndex)
                    {
                        tasks.Insert(targetIndex - 1, Payload);
                    }
                    else
                    {
                        tasks.Insert(targetIndex, Payload);
                    }

                    Payload.Order = targetTask.Order;
                }
            }
            StateHasChanged();
            AutoOrder();
        }
    }


    //protected override void OnParametersSet()
    //{
    //    TaskOrder.Clear();
    //    TaskOrder.AddRange(Container.Tasks.OrderBy(x => x.Order));
    //}



    async Task AutoOrder()
    {
        int order = 1;
        foreach (var task in tasks)
        {
            if (task.isSubTask == false)
            {
                if (task.Status != lastStatus)
                {
                    task.Order = order;
                    await taskService.UpdateTask(task);
                    order++;
                }
            }

        }
        StateHasChanged();
        order = 1;
    }

    async Task AutoOrderSubtaskSet(int linkedBy)
    {
        int order = 1;
        foreach (var subtask in subtasks)
        {
            if (subtask.LinkTo == linkedBy)
            {
                subtask.Order = order;
                await taskService.UpdateTask(subtask);
                order++;
            }

        }
        StateHasChanged();
        order = 1;
    }

    void ToggleAcceptanceCriteriaVisibility()
    {
        ShowOrHideAcceptanceCriteria = !ShowOrHideAcceptanceCriteria;
        StateHasChanged();
    }

    void ResetMessage()
    {
        message = string.Empty;
    }


    protected CompletedTasksComponent? CompletedTasksComponent;

    NoteModel newTask = new NoteModel();
    List<NoteModel> tasks = new List<NoteModel>();
    List<NoteModel> subtasks = new List<NoteModel>();
    List<TaskComponent> taskComponents = new();


    List<Epic> epics = new();

    int lastStatus;

    SprintModel CurrentSprint = new();

    protected override async Task OnInitializedAsync()
    {
        tasks = await taskService.GetTasksInOrder();

        subtasks = await taskService.GetSubtasks();
        await memberService.GetMembers();
        await sprintService.GetSprints();

        CurrentSprint = sprintService.Sprints.Last();

        StatusDTO lastStatusDTO = await statusService.GetLastStatus();
        lastStatus = lastStatusDTO.StatusId;
        isLoading = false;
        StateHasChanged();
        await base.OnInitializedAsync();
    }

    void AddNewTask()
    {
        var nullSubtasks = subtasks.Find(x => x.TaskId == 0);
        var taskWithIdOfZero = tasks.Find(x => x.TaskId == 0);
        if (taskWithIdOfZero == null && nullSubtasks == null)
        {
            tasks.Add(newTask);
            StateHasChanged();
            newTask = new NoteModel();
        }
        else
        {
            message = "Save your newly created task or subtask before creating another.";
        }
    }

    void AddNewSubTask(int taskId)
    {
        var anyTaskWithZero = tasks.Find(x => x.TaskId == 0);
        var taskWithIdOfZero = subtasks.Find(x => x.TaskId == 0);
        if (taskWithIdOfZero == null && anyTaskWithZero == null)
        {
            newTask.isSubTask = true;
            newTask.LinkTo = taskId;
            subtasks.Add(newTask);
            StateHasChanged();
            newTask = new NoteModel();
        }
        else
        {
            message = "Save your newly created task or subtask before creating another.";
        }

    }

    public int sprintIdNumber;


    public async Task RefreshList()
    {
        isLoading = true;
        tasks = await taskService.GetTasksInOrder();
        subtasks = await taskService.GetSubtasks();
        isLoading = false;
        CompletedTasksComponent.ChangeState();
        StateHasChanged();
    }

    void RemoveTaskWithoutCallingDB()
    {
        tasks = tasks.FindAll(x => x.TaskId != 0);
        subtasks = subtasks.FindAll(x => x.TaskId != 0);
    }
}